import ast
import os
import time

import openai


class ChatGPTDocstringGenerator:
    def __init__(
        self,
        api_key: str = None,
        model: str = "gpt-3.5-turbo",
        docstrings_style: str = "google",
    ):
        self.api_key = api_key if api_key else os.getenv("OPENAI_API_KEY")
        self.model = model

        if docstrings_style not in ["google", "numpy" or "reStructuredText"]:
            raise ValueError(
                "Docstring style no found. "
                "Choose between `google`, `numpy` or `reStructuredText`"
            )

        self.docstrings_style = (
            docstrings_style if docstrings_style != "numpy" else "numpydoc"
        )

        if not self.api_key:
            raise ValueError("Please, provide the OpenAI API Key")

        openai.api_key = self.api_key

    def _get_completion(self, prompt: str) -> str:
        """
        Gets completion of prompt using OpenAI API

        Args:
            prompt: ChatGPT prompt

        Returns:
            ChatGPT response
        """
        max_retries = 5
        retries = 0
        messages = [{"role": "user", "content": prompt}]

        while retries < max_retries:
            try:
                response = openai.ChatCompletion.create(
                    model=self.model,
                    messages=messages,
                    temperature=0,  # TODO: Let user configure temperature??
                )
                return response.choices[0].message["content"]
            except openai.error.APIError:
                time.sleep(5)
                retries += 1

    def generate_function_docstring(self, source: str) -> dict:
        """
        Generates docstring for Python function.

        Args:
            source: The source code of the Python method

        Returns:
            A dictionary containing the docstrings generated by ChatGPT
        """
        while source.endswith("\n"):
            source = source[:-1]

        prompt = (
            f"Your task is to document the Python function below using"
            f" {self.docstrings_style} Python docstrings. Output the function with the"
            f" new docstring. Don't import any additional packages.\n\n"
        )
        prompt += "\n" + source + "\n"

        # Use ast in this case because it generates a docstring without unintended indentations
        tree = ast.parse(self._get_completion(prompt))
        function_docs = [
            ast.get_docstring(f)
            for f in ast.walk(tree)
            if isinstance(f, ast.FunctionDef)
        ]
        return {"docstring": f'"""\n{function_docs[0]}\n"""'}

    def generate_class_docstring(self, source: str) -> dict:
        """
        Generates docstring for Python class

        Args:
            source: The source code of the Python class

        Returns:
            A dictionary like the following:

                {'docstring': <class docstring>, '<method1's name>': <docstring for method1>, ...}
        """
        while source.endswith("\n"):
            source = source[:-1]

        prompt = (
            f"Your task is to document the Python class delimited by triple quotes using"
            f" {self.docstrings_style} Python docstrings. Output the class with the new"
            f" docstrings. Don't import any additional packages.\n\n"
        )
        prompt += "'''\n" + source + "\n'''"

        docstrings = {}

        # Use ast in this case because it generates a docstring without unintended indentations
        tree = ast.parse(self._get_completion(prompt))
        class_node = [c for c in ast.walk(tree) if isinstance(c, ast.ClassDef)][0]
        method_nodes = [
            f for f in ast.walk(class_node) if isinstance(f, ast.FunctionDef)
        ]

        for method_node in method_nodes:
            # TODO: This sucks right now because we need to manually modify the indentation.
            #  Need to think about some clever way to obtain the docstrings with the correct indentation
            method_docstring = f'"""\n{ast.get_docstring(method_node)}\n"""'
            indented_method_docstring = ""
            for doc_line in method_docstring.split("\n"):
                # TODO: Right now I have to add tabs instead of spaces which generates a
                #  `PEP 8: W191 indentation contains tabs`. Right now the way to fix this is to manually
                #  refactor the classes or to use tools like `black` for code formatting.
                indented_method_docstring += "\t" + doc_line + "\n"
            docstrings[method_node.name] = indented_method_docstring

        docstrings["docstring"] = f'"""\n{ast.get_docstring(class_node)}\n"""'

        return docstrings
