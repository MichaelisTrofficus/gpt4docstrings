import ast
import os
import textwrap
import time
from typing import List

import openai


class ChatGPTDocstringGenerator:
    def __init__(
        self,
        api_key: str = None,
        model: str = "gpt-3.5-turbo",
    ):
        self.api_key = api_key if api_key else os.getenv("OPENAI_API_KEY")
        self.model = model

        if not self.api_key:
            raise ValueError("Please, provide the OpenAI API Key")

        openai.api_key = self.api_key

    def _get_completion(self, prompt: str, stop: List[str] = None) -> str:
        """
        Gets completion of prompt using OpenAI API

        Args:
            prompt: ChatGPT prompt
            stop: Stop chars

        Returns:
            ChatGPT response
        """
        max_retries = 5
        retries = 0
        messages = [{"role": "user", "content": prompt}]

        while retries < max_retries:
            try:
                response = openai.ChatCompletion.create(
                    model=self.model,
                    messages=messages,
                    temperature=0,  # TODO: Let user configure temperature??
                    stop=stop,
                )
                return response.choices[0].message["content"]
            except openai.error.APIError:
                time.sleep(5)
                retries += 1

    def generate_function_docstring(self, source: str) -> dict:
        """
        Generates docstring for Python function.

        Args:
            source: The source code of the Python method

        Returns:
            A dictionary containing the docstrings generated by ChatGPT
        """
        source = source.strip()
        stripped_source = textwrap.dedent(source)

        prompt = (
            f"{stripped_source} \n\n"
            f"High quality docstring for the above function."
            f"Make sure you are using google-style docstrings: \n\n"
            f'"""'
        )
        stop_words = ["#", '"""']
        return {
            "docstring": f'"""\n{self._get_completion(prompt, stop=stop_words)}\n"""'
        }

    def generate_class_docstring(self, source: str) -> dict:
        """
        Generates docstring for Python class

        Args:
            source: The source code of the Python class

        Returns:
            A dictionary like the following:

                {'docstring': <class docstring>, '<method1's name>': <docstring for method1>, ...}
        """
        source = source.strip()
        stripped_source = textwrap.dedent(source)

        prompt = (
            f"Create elaborate, high quality docstrings for the Python class below."
            f"Make sure you are using google-style docstrings."
            f"The output is the Python class with the new docstrings. \n\n"
            f" {stripped_source} \n"
        )

        docstrings = {}

        # Use ast in this case because it generates a docstring without unintended indentations
        tree = ast.parse(self._get_completion(prompt))
        class_node = [c for c in ast.walk(tree) if isinstance(c, ast.ClassDef)][0]
        method_nodes = [
            f for f in ast.walk(class_node) if isinstance(f, ast.FunctionDef)
        ]

        for method_node in method_nodes:
            docstrings[method_node.name] = f'"""\n{ast.get_docstring(method_node)}\n"""'

        docstrings["docstring"] = f'"""\n{ast.get_docstring(class_node)}\n"""'

        return docstrings
